# Instructions #

- Demonstrate how to develop algorithms using pseudocode and flow charts to solve problems.
- Demonstrate how to translate specifications to program code.

# Demonstration #

In my spare time, I have been working on a plugin for my KOReader-powered Kobo. [KOReader](https://koreader.rocks), for the unitiated, is an open-source document viewer for e-ink devices. When I got my Kobo in November 2020, the promise of developing my own plugins using KOReader was far more exciting to me than actually, you know... reading.

KOReader's front-end is written in Lua, which is a scripting language. Using a scripting language for building user-interface widgets and other front-end services was a great choice for this project. Scripting languages do not need to be compiled. Instead, they are interpreted a runtime. For me, as a developer, this means that I can work in an iterative manner, writting code and testing it quickly without having to compile. It also means I don't have to worry (too much) about low-level system resources like memory. 

My first plugin for KOReader was a [weather forecaster](https://github.com/roygbyte/weather.koplugin). Weather is fetched from [WeatherAPI](https://weatherapi.com) using a postal code set by the user. There are a number of views for seeing weekly forecasts, daily forecasts, and hourly forecasts. By no means is it very sophisticated. In fact, it's quite ugly... most of the views are constructed as two-column lists. I'd love to make it more pretty in the future by writing fancy views with icons and whatnot. But that's not what I'm up to now.

My current KOReader project is a crossword plugin. I've been developing it for a number of weeks, picking on this or that feature whenever I am in the mood. It's a fairly complicated endeavor and has required some clever thinking about how to best render views and how to store game data in an intuitive, non-spaghetti manner. Currently, the code is structured into the following files/classes:

- main.lua
  - gameview.lua
	- puzzle.lua
		- solve.lua
	- gridview.lua
		- gridrow.lua
		- gridsquare.lua
- softkeyboard.lua

## main.lua ##
The most top-level file, so to speak. This file includes logic for starting a new crossword and selecting the folder to use for game data.

## gameview.lua ##
This file contains the `InputContainer` for managing the player's game. `GameView` builds the `Puzzle` and the `GridView`. It also listens for input events that are triggered gestures and keyboard input.

## puzzle.lua ##
This file contains the class which holds onto all of the information about the current crossword. `Puzzle` doesn't directly interact with the view (`GameView`). Instead, it has a number of methods that return information like the color of the squares, the letters inside the squares, and the active square. Here are some examples of what methods this file includes:

- `Puzzle:getGrid()`
- `Puzzle:setActiveSquare()`
- `Puzzle:getSquareAtPos(row, col)`
- `Puzzle:getNextCluePos(row, col, direction)`
- `Puzzle:createSolves(clues, answers, direction, grid_nums)`

And here are some excerpts from the more interesting methods:

```lua
function Puzzle:getSquareAtPos(row, col)
    local index = ((row - 1) * self.size.rows) + col
    return self.solves[index]
end
```

```lua
function Puzzle:getNextIndexForDirection(index, direction)
    index = index + 1
    local solve = self.solves[index]
    -- If solve is nil, we're probably at the end of the list,
    -- so call this method again from start of list (but we call the
    -- method with '0' because the function will advance the index to 1.
    if solve == nil then
        return self:getNextIndexForDirection(0, direction)
    end
    -- If solve direction does not match desired direction, advance
    -- the index and call this method again.
    if solve.direction ~= direction then
        return self:getNextIndexForDirection(index, direction)
    end
    -- If we made it this far then we have the next solve.
    return solve
end
```

`Puzzle:getNextIndexForDirection(index, direction)` is kinda interesting, since it includes a bet of recursion to deal with edge cases where the index given to this method exceeds the list of solves ("solves" are what I call the clue/grid number/answer combos, e.g.: 2. (Down) Beta predecessor). I should probably rename the method, though, as I see now that it returns the next solve and not the next index, as the method signature deceptively indicates. 

## solve.lua ##
This file is used to model each of the clue/grid/answer combos that make up any given crossword. One of the early challenges of this project was figuring out how to eliminate redundancy in the data models. It would get pretty confusing, I thought, if I had separate models for the grid and for the solves. So I decided to avoid having a grid model. Instead, the grid is generated by `Puzzle:getGrid`, which basically iterates through the list of solves and builds the grid by looking at field called `grid_indices` and another called `grid_num`. `grid_indices` contains an integer representing each index on the grid that is occupied by one of a solve's letters. For example: if the word "ALPHA" begins at the first square on the puzzle and runs across, `grid_indices` would contain: `[1,2,3,4,5]`. Likewise, if the word "APPLE" began at the first square on a puzzle and runs down (on a 10 by 10 puzzle), `grid_indices` would contain `[1, 11, 21, 31, 41]`. `grid_num` contains the first value of this list (so `1`). Probably, that's redundant and could be removed. However: this value is supplied by the data that generates the crossword puzzle. It's a very important tidbit so I guess I'd like to keep it around.

So, how is `grid_indices` constructed for each solve? Great question! I found this problem a bit of a brain jogger and when I finally nailed it, I felt like superwoman. The only values that need to be known are:

- The size of the crossword (rows and columns)
- The index corresponding to the solve's first letter
- The length of the solve

For solves going down, the solution can be expressed declaratively as what follews: the grid indices occupied by the word are those indices whose value is the same as the value found by adding the the grid index corresponding to the first letter of the word to the width of the crossword grid multiplied by the given index of the word's character. (Thinking declaratively is new for me, so in exchange for your patience I give you my apologies!) Here is part of the method that populates `grid_indices` for a given solve:

```lua
function Solve:init(puzzle_size, puzzle_grid_nums)
    ...
	
    -- Compute the grid indices. I.e.: each index on the grid that
    -- is occupied by one of this solve's letters.
    self.grid_indices = {}
    local word_length = string.len(self.word)
    local width = puzzle_size.cols
    local height = puzzle_size.rows

    if self.direction == Solve.DOWN then
        local index = 0
        for char in string.gmatch(self.word, "[A-Z]") do
            local grid_index = self.grid_num + (index * width)
            table.insert(self.grid_indices, grid_index)
            index = index + 1
        end
    elseif self.direction == Solve.ACROSS then
        local index = 0
        for char in string.gmatch(self.word, "[A-Z]") do
            local grid_index = self.grid_num + index
            table.insert(self.grid_indices, grid_index)
            index = index + 1
        end
    end
end
```

Expressed imperatively, the answer can be found by the following steps:

1. Get the length of the solve's answer (e.g.: `5` for "APPLE").
2. Iterate over each character in the word (e.g.: "A", "P", "P", ...).
3. Find the grid index by adding the location of the first letter to the width of the puzzle muliplied by the current character index.

Tada! And that's basically all this file is for.
